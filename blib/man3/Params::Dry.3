.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Params::Dry 3"
.TH Params::Dry 3 "2013-07-24" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Params \- Simple Global Params Management System
.SH "VERSION"
.IX Header "VERSION"
version 1.00
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Fast start!"
.IX Subsection "Fast start!"
.IP "\fBtypedef\fR \- defines global types for variables" 2
.IX Item "typedef - defines global types for variables"
.PD 0
.IP "\fB_\|_@_\fR \- starts parameter fetching" 2
.IX Item "__@_ - starts parameter fetching"
.IP "\fBrq/param_rq\fR \- get required parameter" 2
.IX Item "rq/param_rq - get required parameter"
.IP "\fBop/param_op\fR \- get optional parameter" 2
.IX Item "op/param_op - get optional parameter"
.IP "\fBno_more\fR \- marks that all parametrs has been fetched (required only in some cases)" 2
.IX Item "no_more - marks that all parametrs has been fetched (required only in some cases)"
.PD
.SS "Example:"
.IX Subsection "Example:"
.Vb 1
\&    package ParamsTest;
\&
\&    use strict;
\&    use warnings;
\&
\&    our $VERSION = 1.0;
\&
\&    #=\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-( use, constants )
\&
\&    use Params::Dry qw(:short);
\&
\&    #=\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-( typedef definitions )
\&
\&    # \-\-\- how to define types?  \- its Easy :)
\&    typedef \*(Aqname\*(Aq, \*(AqString[20]\*(Aq;   
\&  
\&    typedef \*(Aqsubname\*(Aq, \*(Aqname\*(Aq;  # even Easier :)  
\&
\&    #=\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-( functions )
\&
\&
\&    sub new {
\&        
\&        # \-\-\- using parameters :)
\&        
\&        my $self = _\|_@_;    # inteligent _\|_ function will return $self on \*(Aq$self\->new\*(Aq call or undef on \*(Aqnew\*(Aq call
\&        
\&        # \-\-\- geting parameters data 
\&
\&        #+ required parameter name (in \*(Aqname\*(Aq (autodetected) type (see typedefs above) with no default value)
\&        my $p_name          = rq \*(Aqname\*(Aq; # this is using default type for required parameter name without default value
\&
\&        #+ optional parameter second_name (in \*(Aqname\*(Aq type (see typedefs above) with default value \*(Aqunknown\*(Aq)
\&        my $p_second_name   = op \*(Aqsecond_name\*(Aq, \*(Aqname\*(Aq, \*(Aqunknown\*(Aq; # this is using name typee for optional parameter name with default value set to \*(Aqunknown\*(Aq
\&
\&        #+ optional parameter details (in build\-in \*(AqString\*(Aq type  with default value \*(Aq\*(Aq)
\&        my $p_details       = op \*(Aqdetails\*(Aq, \*(AqString\*(Aq, \*(Aq\*(Aq; # unlimited string for optional parameter details
\&        
\&        return bless { 
\&                    name        => $p_name,
\&                    second_name => $p_second_name,
\&                    details     => $p_details, 
\&                }, \*(AqParamsTest\*(Aq;
\&    }
\&
\&    my $lucja = new(name => \*(AqLucja\*(Aq, second_name => \*(AqMarta\*(Aq);
.Ve
.PP
\&\fBMore you can find in examples\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Understand main concepts"
.IX Subsection "Understand main concepts"
First. If you can use any function as in natural languague \- you will use and understand it even after few months.
.PP
Second. Your lazy life will be easy, and you will reduce a lot of errors if you will have guarancy that your parameter 
in whole project means the same ( ex. when you see 'client' you know that it is always String[32] ).
.PP
Third. You want to set the type in one and only in one place.
.PP
Yes, \s-1DRY\s0 principle in its pure form!
.PP
So all your dreams you can now find in this module.
.PP
\&\fBThat's all. Easy to use. Easy to manage. Easy to understand.\fR
.SH "EXPORT"
.IX Header "EXPORT"
.IP "\fB:short\fR imports: 'op', 'rq' and common ones" 2
.IX Item ":short imports: 'op', 'rq' and common ones"
.PD 0
.IP "\fB:long\fR imports: 'param_op', 'param_rq' and common ones" 2
.IX Item ":long imports: 'param_op', 'param_rq' and common ones"
.PD
.PP
Common ones mean: '_\|_', 'typedef', 'no_more', \s-1DEFAULT_TYPE\s0
.SH "CONSTANTS AND VARIABLES"
.IX Header "CONSTANTS AND VARIABLES"
.IP "\fB\s-1TRUE\s0\fR \- set to 1" 2
.IX Item "TRUE - set to 1"
.PD 0
.IP "\fB\s-1FALSE\s0\fR \- set to 0" 2
.IX Item "FALSE - set to 0"
.IP "\fB\s-1OK\s0\fR \- set to \s-1TRUE\s0 (1)" 2
.IX Item "OK - set to TRUE (1)"
.IP "\fB\s-1NO\s0\fR \- set to \s-1FALSE\s0 (0)" 2
.IX Item "NO - set to FALSE (0)"
.IP "\fB\s-1DEFAULT_TYPE\s0\fR \- to mark that you want to use default type" 2
.IX Item "DEFAULT_TYPE - to mark that you want to use default type"
.ie n .IP "\fB\fB$Debug\fB\fR \- if set to \s-1TRUE\s0 (default: \s-1FALSE\s0) will show more debug" 2
.el .IP "\fB\f(CB$Debug\fB\fR \- if set to \s-1TRUE\s0 (default: \s-1FALSE\s0) will show more debug" 2
.IX Item "$Debug - if set to TRUE (default: FALSE) will show more debug"
.PD
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.ie n .SS "\fB_\|_\fP \- turtle operator Start getting the parameters. Used on the begin of the function sub pleple { my $self = _\|_@_;"
.el .SS "\fB_\|_\fP \- turtle operator Start getting the parameters. Used on the begin of the function sub pleple { my \f(CW$self\fP = _\|_@_;"
.IX Subsection "__ - turtle operator Start getting the parameters. Used on the begin of the function sub pleple { my $self = __@_;"
\&\s-1RETURN:\s0 first param if was called like \f(CW$obj\fR\->pleple(%params) or undef on pleple(%params) call
.SS "\fBrq\fP or \fBparam_rq\fP \- required parameter Check if required parameter exists, if yes check if its valid, if not, report error"
.IX Subsection "rq or param_rq - required parameter Check if required parameter exists, if yes check if its valid, if not, report error"
\&\fBrq\fR \f(CW\*(C`in param name\*(C'\fR [\f(CW\*(C`in param type\*(C'\fR, [\f(CW\*(C`default value\*(C'\fR]]
    sub pleple {
        my \f(CW$self\fR = _\|_@_;
.PP
.Vb 4
\&        my $p_param1 = rq \*(Aqparam1\*(Aq; # assuming that param1 is defined before by typedef
\&        my $p_param2 = rq \*(Aqparam2\*(Aq, \*(AqString\*(Aq;
\&        my $p_param3 = rq \*(Aqparam3\*(Aq, \*(AqString\*(Aq, \*(AqDefault value\*(Aq;
\&        my $p_param4 = rq \*(Aqparam4\*(Aq, DEFAULT_TYPE, \*(AqDefault value\*(Aq; # assuming that param4 is defined before but wanted to give default value
\&
\&    ...
\&
\&    pleple(param1 => \*(Aqtest\*(Aq, param2 => \*(Aqbleble\*(Aq);
.Ve
.PP
\&\s-1RETURN:\s0 parameter value
.SS "\fBop\fP or \fBparam_op\fP \- optional parameter Check if required parameter exists, if yes check it, if not return undef"
.IX Subsection "op or param_op - optional parameter Check if required parameter exists, if yes check it, if not return undef"
\&\fBop\fR \f(CW\*(C`in param name\*(C'\fR [\f(CW\*(C`in param type\*(C'\fR, [\f(CW\*(C`default value\*(C'\fR]]
.PP
\&\f(CW\*(C`see above\*(C'\fR
.PP
.Vb 1
\&    my $p_param1 = op \*(Aqparam1\*(Aq; # .. see above
.Ve
.PP
\&\s-1RETURN:\s0 parameter value
.SS "\fBno_more\fP \- marks that no more parameters will be readed It can be useful in some cases, for example whan default value of the param is the function call and this function is using parameters as well."
.IX Subsection "no_more - marks that no more parameters will be readed It can be useful in some cases, for example whan default value of the param is the function call and this function is using parameters as well."
The function is getting from internal stack previous parameters
.PP
Example.
    sub get_val {
        my \f(CW$self\fR = _\|_@_;
.PP
.Vb 1
\&        my $p_name = rq \*(Aqname\*(Aq;
\&
\&        no_more; # to give back old parameters
\&
\&    }
\&
\&    sub main {
\&        my $self = _\|_@_;
\&        
\&        my $p_nick = rq \*(Aqnick\*(Aq, \*(AqString\*(Aq, $self\->get_val(name => \*(Aqsomename\*(Aq);
\&
\&    }
.Ve
.PP
It is good practice to use no_more at the end of geting parameters
Also the strict parameter checking implementation is planed in next releases
(so using no_more you will be able to die if apear more parameters that was fetched \- to avoid misspelings)
.SH "BUILD IN TYPES"
.IX Header "BUILD IN TYPES"
.IP "\fBString\fR \- can be used with parameters (like: String[20]) which mean max 20 chars string" 2
.IX Item "String - can be used with parameters (like: String[20]) which mean max 20 chars string"
.PD 0
.IP "\fBInt\fR \- can be used with parameters (like: Int[3]) which mean max 3 chars int not counting signs" 2
.IX Item "Int - can be used with parameters (like: Int[3]) which mean max 3 chars int not counting signs"
.IP "\fBFloat\fR \- number with decimal part" 2
.IX Item "Float - number with decimal part"
.IP "\fBBool\fR \- boolean value (can be 0 or 1)" 2
.IX Item "Bool - boolean value (can be 0 or 1)"
.IP "\fBObject\fR \- check if is an object. Optional parameter extend check of exact object checking ex. Object[DBI::db]" 2
.IX Item "Object - check if is an object. Optional parameter extend check of exact object checking ex. Object[DBI::db]"
.IP "\fBRef\fR \- any reference, Optional parameter defines type of the reference" 2
.IX Item "Ref - any reference, Optional parameter defines type of the reference"
.IP "\fBScalar\fR \- short cut of Ref[Scalar]" 2
.IX Item "Scalar - short cut of Ref[Scalar]"
.IP "\fBArray\fR \- short cut of Ref[Array]" 2
.IX Item "Array - short cut of Ref[Array]"
.IP "\fBHash\fR \- short cut of Ref[Hash]" 2
.IX Item "Hash - short cut of Ref[Hash]"
.IP "\fBCode\fR \- short cut of Ref[Code]" 2
.IX Item "Code - short cut of Ref[Code]"
.PD
.SH "EXTENDING INTERNAL TYPES"
.IX Header "EXTENDING INTERNAL TYPES"
You can always write your module to check parameters. Please use always subnamespace of Params::Dry::Types
.PP
You will to your check function \f(CW\*(C`param value\*(C'\fR and list of the type parameters
.PP
Example.
.PP
.Vb 1
\&    package Params::Dry::Types::Super;
\&
\&    use Params::Dry::Types qw(:const);
\&
\&    sub String {
\&        Params::Dry::Types::String(@_) and $_[0] =~ /Super/ and return PASS;
\&        return FAIL;
\&    }
\&
\&    ...
\&
\&    package main;
\&
\&    sub test {
\&        my $self = _\|_@_;
\&
\&        my $p_super_name = rq \*(Aqsuper_name\*(Aq, \*(AqSuper::String\*(Aq; # that\*(Aqs all folks!
\&        
\&        ...
\&    }
.Ve
.SH "ADDITIONAL INFORMATION"
.IX Header "ADDITIONAL INFORMATION"
\&\fB1. I didn't wrote here any special extensions (callbacks, ordered parameter list, evals etc). Params::Dry module has to be fast.\fR
.PP
If there will be any extension in future. It will be in separate module.
.PP
\&\fB2. Ordered parameters list or named parameter list? Named parameter list. For sure.\fR
.PP
Majority of the time you are spending on \s-1READING\s0 code, not writing it. So for sure named parameter list is better.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pawel Guspiel (neo77), \f(CW\*(C`<neo at cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-params at rt.cpan.org\*(C'\fR, or through
the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params\-Dry <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Dry>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Params::Dry
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker (report bugs here)
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Params\-Dry <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Params-Dry>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/Params\-Dry <http://annocpan.org/dist/Params-Dry>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/Params\-Dry <http://cpanratings.perl.org/d/Params-Dry>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/Params\-Dry/ <http://search.cpan.org/dist/Params-Dry/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2013 Pawel Guspiel (neo77).
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the the Artistic License (2.0). You may obtain a
copy of the full license at:
.PP
<http://www.perlfoundation.org/artistic_license_2_0>
.PP
Any use, modification, and distribution of the Standard or Modified
Versions is governed by this Artistic License. By using, modifying or
distributing the Package, you accept this license. Do not use, modify,
or distribute the Package, if you do not accept this license.
.PP
If your Modified Version has been derived from a Modified Version made
by someone other than you, you are nevertheless required to ensure that
your Modified Version complies with the requirements of this license.
.PP
This license does not grant you the right to use any trademark, service
mark, tradename, or logo of the Copyright Holder.
.PP
This license includes the non-exclusive, worldwide, free-of-charge
patent license to make, have made, use, offer to sell, sell, import and
otherwise transfer the Package with respect to any patent claims
licensable by the Copyright Holder that are necessarily infringed by the
Package. If you institute patent litigation (including a cross-claim or
counterclaim) against any party alleging that the Package constitutes
direct or contributory patent infringement, then this Artistic License
to you shall terminate on the date that such litigation is filed.
.PP
Disclaimer of Warranty: \s-1THE\s0 \s-1PACKAGE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \s-1BY\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0
\&\s-1AND\s0 \s-1CONTRIBUTORS\s0 "\s-1AS\s0 \s-1IS\s0' \s-1AND\s0 \s-1WITHOUT\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0.
\&\s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0, \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0
\&\s-1PURPOSE\s0, \s-1OR\s0 NON-INFRINGEMENT \s-1ARE\s0 \s-1DISCLAIMED\s0 \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0
\&\s-1YOUR\s0 \s-1LOCAL\s0 \s-1LAW\s0. \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1LAW\s0, \s-1NO\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0 \s-1OR\s0
\&\s-1CONTRIBUTOR\s0 \s-1WILL\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1DIRECT\s0, \s-1INDIRECT\s0, \s-1INCIDENTAL\s0, \s-1OR\s0
\&\s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1IN\s0 \s-1ANY\s0 \s-1WAY\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OF\s0 \s-1THE\s0 \s-1PACKAGE\s0,
\&\s-1EVEN\s0 \s-1IF\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGE\s0.
